#!/usr/bin/env python3
# This file is placed in the Public Domain.
#
# pylint: disable=C0412,C0115,C0116,W0212,R0903,C0207,C0413,W0611
# pylint: disable=C0411,E0402,E0611,C2801


"runtime"


import getpass
import importlib
import os
import pwd
import readline
import shutil
import sys
import termios
import time
import threading
import traceback


sys.path.insert(0, os.getcwd())


from bot.brokers import Broker
from bot.configs import Cfg
from bot.errored import Errors, debug, output
from bot.methods import parse
from bot.handler import Client, Event, Handler, command, scan
from bot.storage import Storage
from bot.threads import launch
from bot.utility import daemon, mods, privileges, spl


from bot import errored
from bot import handler
from bot import modules


NAME = __file__.split(os.sep)[-1].lower()
Storage.workdir = os.path.expanduser(f"~/.{NAME}")
PIDFILE = os.path.join(Storage.workdir, "{NAME}.pid")
USER = getpass.getuser()
VERSION = 20


Cfg.name = NAME


def cprint(txt):
    print(txt)
    sys.stdout.flush()


errored.output = cprint


class CLI(Client):

    def announce(self, txt):
        pass

    def raw(self, txt):
        print(txt)
        sys.stdout.flush()


class Console(CLI):

    def dispatch(self, evt):
        parse(evt)
        command(evt)
        evt.wait()

    def poll(self) -> Event:
        return self.event(input("> "))


def ver(event):
    event.reply(f"{NAME.upper()} {VERSION}")


def scan(path, modnames="", initer=False, dowait=False) -> []:
    if not os.path.exists(path):
        return []
    inited  = []
    scanned = []
    threads = []
    fnames  = [x[:-3] for x  in os.listdir(path) if (x.endswith('py') and not x.startswith("__"))]
    sys.path.insert(0, os.path.dirname(path))
    pname = path.split(os.sep)[-1]
    for mname in fnames:
        if mname not in modnames:
            continue
        module = importlib.import_module(f"{pname}.{mname}")
        if not module:
            continue
        scanned.append(mname)
        Handler.scan(module)
        Storage.scan(module)
        if initer:
            try:
                module.init
            except AttributeError:
                continue
            inited.append(mname)
            threads.append(launch(module.init, name=f"init {mname}"))
    if dowait:
        for thread in threads:
            thread.join()
    return fnames


def wrap(func) -> None:
    old = None
    try:
        old = termios.tcgetattr(sys.stdin.fileno())
    except termios.error:
        pass
    try:
        func()
    except (EOFError, KeyboardInterrupt):
        print("")
        sys.stdout.flush()
    finally:
        if old:
            termios.tcsetattr(sys.stdin.fileno(), termios.TCSADRAIN, old)
    Errors.show()


def main():
    mods = modules.__path__[0]
    parse(Cfg, " ".join(sys.argv[1:]))
    
    Cfg.mod = ",".join(
                       [
                        x[:-3] for x in os.listdir(Storage.mods())
                        if not x.startswith("__")
                       ]
                      )
    if "d" in Cfg.opts:
        daemon()
    if "d" in Cfg.opts or "s" in Cfg.opts:
        privileges(getpass.getuser())
        debug(f"dropped to {USER} privileges")
        scan(mods, Cfg.mod, True)
        while 1:
            time.sleep(1.0)
    elif "c" in Cfg.opts:
        dtime = time.ctime(time.time()).replace("  ", " ")
        debug(f"{NAME.upper()} started at {dtime} {Cfg.opts.upper()} {Cfg.mod.upper()}")
        scan(mods, Cfg.mod, True, True)
        csl = Console()
        csl.add(ver)
        csl.start()
        csl.forever()
    else:
        cli = CLI()
        cli.add(ver)
        scan(Storage.mods(), Cfg.mod)
        evt = cli.event(Cfg.otxt)
        parse(evt)
        command(evt)
        evt.wait()


def wrapped():
    wrap(main)


if __name__ == "__main__":
    wrapped()
